# 사용자 플로우 및 기능 분석 - 논리적 문제점 보고서

## 1. 현재 사용자 플로우 요약

```
앱 진입
 └─ 현재 월 근태표 표시 (주차별 그룹)
     ├─ 월 이동: ◀ 이전 / 다음 ▶
     ├─ 월간 요약 카드: 목표시간 | 누적시간 | 부족/초과 | 남은일수 | 일평균
     ├─ 일별 입력: 출근시간 | 퇴근시간 | (점심시간 고정표시) | 제외시간 | 메모
     ├─ 퀵입력 버튼: 기본 | 연차 | 오전반차 | 오후반차 | 초기화(✕)
     ├─ 목표시간 수정: 카드 클릭 → 인라인 편집
     └─ 데이터 관리: 내보내기(JSON) | 가져오기(JSON)
```

---

## 2. 논리적 문제점 (심각도별 정리)

### [심각] 반차 근무시간 계산 오류

**위치**: `WorkHoursTracker.jsx:139-150`

```javascript
const setHalfLeave = (date, type = 'am') => {
  startTime: type === 'am' ? '13:00' : '08:00',
  endTime: type === 'am' ? '17:30' : '12:30',
  lunchTime: type === 'am' ? 0 : 0,
};
```

**문제**: 주석에는 "반차 퀵입력 (4시간)"이라고 명시되어 있으나, 실제 계산 결과는 **4시간 30분**이다.

| 반차 유형 | 계산 | 결과 | 기대값 |
|-----------|------|------|--------|
| 오전반차 | 17:30 - 13:00 - 0 | **4:30** | 4:00 |
| 오후반차 | 12:30 - 08:00 - 0 | **4:30** | 4:00 |

실제 4시간이 되려면 오전반차는 `13:30~17:30`, 오후반차는 `08:00~12:00`이어야 한다. 혹은 회사 규정상 4:30이 맞다면 주석을 수정해야 한다.

---

### [심각] 점심시간 칼럼 표시값과 실제 데이터 불일치

**위치**: `WorkHoursTracker.jsx:580-582`

```javascript
<td style={{ ... }}>
  1:30:00
</td>
```

**문제**: 점심시간 칼럼이 항상 `1:30:00`으로 하드코딩되어 있다. 그러나 실제 `record.lunchTime`은 0이 될 수 있다(반차 시).

- 반차를 입력하면 `lunchTime: 0`으로 저장되지만, UI에는 "1:30:00"으로 표시
- 사용자는 점심시간이 적용된 것으로 오인할 수 있음
- 실근무시간은 `lunchTime: 0`으로 올바르게 계산되지만, 표시값과 계산값이 모순

**부가 문제**: 표시 형식 "1:30:00"에 초(seconds)가 포함되어 있으나, 다른 모든 시간 표시는 "H:MM" 형식을 사용한다. 형식 불일치.

---

### [중간] 점심시간 사용자 수정 불가

**위치**: `WorkHoursTracker.jsx:580-582`

데이터 구조상 `lunchTime` 필드가 존재하고 계산에 반영되지만, UI에서는 읽기 전용 하드코딩 텍스트로만 표시된다. 사용자가 점심시간을 1시간(60분)이나 0분으로 변경하고 싶어도 방법이 없다. 유일한 우회 방법은 "제외시간"을 음수로 넣는 것인데, input에 `min="0"`이 설정되어 있어 그마저도 불가능하다.

---

### [중간] 공휴일 데이터 2026년 한정

**위치**: `WorkHoursTracker.jsx:31-51`

월 이동에 연도 제한이 없어 사용자가 2025년이나 2027년으로 자유롭게 이동할 수 있다. 그러나 공휴일 데이터는 2026년만 하드코딩되어 있어:

- 2025년 이전 또는 2027년 이후 월로 이동하면 공휴일이 전혀 표시되지 않음
- 공휴일인 날이 일반 평일로 취급되어 "남은 근무일"에 포함됨
- 사용자에게 연도 제한에 대한 안내가 없음

---

### [중간] 12시간 초과 검증 기준 부적절

**위치**: `WorkHoursTracker.jsx:189-191`

```javascript
const workMinutes = endMinutes - startMinutes;
if (workMinutes > 720) {
  errors.push('12시간 초과 근무');
}
```

`workMinutes`가 출근~퇴근 총 체류시간(점심·제외시간 차감 전)이다. 08:00~21:00(13시간 체류) 근무자의 경우 실근무는 11:30인데도 경고가 표시된다. 실근무시간 기준으로 판단하는 것이 더 적합하다.

---

### [경미] `lunchTime: type === 'am' ? 0 : 0` 불필요한 삼항연산

**위치**: `WorkHoursTracker.jsx:146`

양쪽 모두 0을 반환하는 삼항연산자는 `lunchTime: 0`으로 단순화해야 한다. 현재 코드는 AM/PM별로 다른 점심시간을 적용하려다 마는 것처럼 보여 의도를 혼동시킨다.

---

### [경미] 데이터 가져오기가 병합 방식

**위치**: `WorkHoursTracker.jsx:226`

```javascript
if (data.records) setRecords(prev => ({ ...prev, ...data.records }));
```

Import 시 기존 데이터를 완전히 대체하지 않고 병합(merge)한다. 같은 날짜는 덮어쓰이지만 임포트 파일에 없는 날짜의 기존 데이터는 유지된다. 사용자가 "백업 복원"으로 인식하면 예기치 않은 데이터 혼합이 발생할 수 있으며, 이에 대한 안내가 없다.

---

### [경미] `today` 변수의 렌더링 시점 고정

**위치**: `WorkHoursTracker.jsx:28`

```javascript
const today = new Date().toISOString().split('T')[0];
```

컴포넌트 렌더링 시점에 계산되며 `useMemo`나 별도 갱신 로직이 없다. 앱을 자정 이후까지 열어두면 "오늘" 하이라이트가 갱신되지 않는다. 실사용에서 빈도가 낮지만, 야근 후 다음날 아침에 입력하는 시나리오에서 발생 가능하다.

---

### [경미] 주차 계산이 일요일 기준

**위치**: `WorkHoursTracker.jsx:107`

```javascript
weekNumber: Math.ceil((day + new Date(year, month - 1, 1).getDay()) / 7)
```

주차가 일요일 기준으로 시작된다. 한국 달력 관행에서는 일요일 시작이 일반적이므로 크게 문제되지 않으나, ISO 8601(월요일 시작) 기준과는 다르다.

---

## 3. 기능별 전체 현황

| 기능 | 상태 | 비고 |
|------|------|------|
| 월 이동 | 정상 | 연도 제한 없음 (공휴일 문제와 연결) |
| 일별 시간 입력 | 정상 | 출근/퇴근/제외시간 수정 가능 |
| 점심시간 | **표시 불일치** | 고정 표시, 실제 데이터와 괴리 |
| 실근무시간 계산 | 정상 | `endTime - startTime - lunchTime - excludeTime` |
| 연차 퀵입력 | 정상 | 8시간 (08:00~17:30, 점심90분) |
| 반차 퀵입력 | **계산 오류** | 4:30 산출 (4:00 기대) |
| 기본근무 퀵입력 | 정상 | 8시간 (08:00~17:30, 점심90분) |
| 초기화 | 정상 | 레코드 완전 삭제 |
| 목표시간 설정 | 정상 | 월별 독립 설정 |
| 월간 통계 | 정상 | 누적/부족/초과/일평균 정확 |
| 남은 근무일 | 부분 정상 | 타 연도 공휴일 미반영 |
| 유효성 검사 | **기준 부적절** | 체류시간 기준 (실근무 기준이 아님) |
| 데이터 내보내기 | 정상 | JSON 다운로드 |
| 데이터 가져오기 | **안내 부족** | 병합 동작에 대한 설명 없음 |
| 공휴일 표시 | 2026년 한정 | 타 연도 미지원 |
